#!/usr/bin/env python3

#
# Strips the KAT harness produced by the Dilithium reference implementation down
# to a less space consuming version. This script was used to generate
# `src/tests/data/pubkey/dilithium_[...].vec` test data from the *.rsp files of
# the reference implemenation.
#
# (C) 2022 Jack Lloyd
# (C) 2022 Ren√© Meusel, Rohde & Schwarz Cybersecurity
#
# Botan is released under the Simplified BSD License (see license.txt)
#

import sys
import hashlib
import binascii

if len(sys.argv) != 2:
  print("Usage: %s <KAT *.rsp file generated by reference implementation>" % sys.argv[0])
  sys.exit(1)

# Store the last message length to cut the message
# off the signature. Note that this assumes mlen
# to always appear before sm.
last_mlen = 0

def process_line(line):
  global last_mlen

  # Comments and empty lines aren't touched.
  if l.startswith("#") or l.startswith("\n"):
    print(l, end="")
    return

  k, v = line.split(" = ")

  # Filter out unwanted parameters.
  if k in ["smlen"]:
    return

  # Don't touch parameters that we can use just the same.
  if k in ["count", "seed", "msg"]:
    print(l, end="")
    return

  # Hash the keys (as they are derived from the seed anyway).
  # We use the hash to ensure successful key derivation but
  # save the bytes needed to store all those long PQC keys.
  if k in ["pk","sk"]:
    h = hashlib.sha3_256()
    h.update(binascii.unhexlify(v[:-1]))
    print("%s_sha3_256 = %s" % (k, h.hexdigest()))

  # Keep the current message length.
  if k == "mlen":
    last_mlen = int(v)

  # Truncate the message from the signed message parameter
  if k == "sm":
    print("sm = %s" % v[:-last_mlen * 2 - 1]) # 2 for hex encoding; 1 for \n

with open(sys.argv[1], "r") as f:
  for l in f.readlines():
    process_line(l)
