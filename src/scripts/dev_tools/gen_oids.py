#!/usr/bin/env python3

"""
(C) 2016,2025 Jack Lloyd
(C) 2017 Fabian Weissberg, Rohde & Schwarz Cybersecurity

Botan is released under the Simplified BSD License (see license.txt)
"""

import sys
import datetime
import re
from collections import defaultdict

def format_oid(oid):
    #return '"' + oid + '"'
    return "{" + oid.replace('.', ', ') + '}'

def format_map(m, for_oid = False):
    s = ''
    for k in sorted(m.keys()):
        v = m[k]

        if len(s) > 0:
            s += '      '

        if for_oid:
            s += '{"%s", %s},\n' % (k,format_oid(v))
        else:
            s += '{%s, "%s"},\n' % (format_oid(k),v)

    s = s[:-2] # chomp last two chars

    return s


def format_as_map(oid2str, str2oid):
   return """/*
* OID maps
*
* This file was automatically generated by %s on %s
*
* All manual edits to this file will be lost. Edit the script
* then regenerate this source file.
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#include <botan/internal/oid_map.h>
#include <unordered_map>

namespace Botan {

std::unordered_map<OID, std::string> OID_Map::load_oid2str_map() {
   std::pair<std::vector<uint32_t>, const char*> oid_maps[] = {
      %s};

   std::unordered_map<OID, std::string> map;

   for(auto& entry : oid_maps) {
      map.insert(std::make_pair(OID(std::move(entry.first)), entry.second));
   }

   return map;
}

std::unordered_map<std::string, OID> OID_Map::load_str2oid_map() {
   std::pair<const char*, std::vector<uint32_t>> oid_maps[] = {
      %s};

   std::unordered_map<std::string, OID> map;

   for(auto& entry : oid_maps) {
      map.insert(std::make_pair(std::string(entry.first), OID(std::move(entry.second))));
   }

   return map;
}

}  // namespace Botan
""" % (
    sys.argv[0],
    datetime.date.today().strftime("%Y-%m-%d"),
    format_map(oid2str),
    format_map(str2oid, True))

def format_dn_ub_map(dn_ub, oid2str):
    s = ''
    for k in sorted(dn_ub.keys()):
        v = dn_ub[k]

        expr = "   {{%s}, %s}, " % (k.replace('.', ', '), v)
        s += expr
        s += ' '*(32 - len(expr))
        s += ' // %s\n' % (oid2str[k])

    # delete last ',' and \n
    idx = s.rfind(',')
    if idx != -1:
        s = s[:idx] + ' ' + s[idx+1:-1]

    return s


def main(args = None):
    """
    Regenerate src/lib/asn1/oid_maps.cpp
    """
    if args is None:
        args = sys.argv

    oid_lines = open('./src/build-data/oids.txt').readlines()

    oid_re = re.compile(r"^([0-9][0-9.]+) += +([A-Za-z0-9_\./\(\), -]+)(?: = )?([0-9]+)?$")
    hdr_re = re.compile(r"^\[([a-z0-9_]+)\]$")

    oid2str = {}
    str2oid = {}
    cur_hdr = None

    for line in oid_lines:
        line = line.strip()
        if len(line) == 0:
            continue

        if line[0] == '#':
            continue

        match = hdr_re.match(line)
        if match is not None:
            cur_hdr = match.group(1)
            continue

        match = oid_re.match(line)
        if match is None:
            raise Exception(line)

        oid = match.group(1)
        nam = match.group(2)

        if oid in str2oid:
            print("Duplicated OID", oid, name, oid2str[oid])
            sys.exit() # hard error
        else:
            oid2str[oid] = nam

        if nam in str2oid:
            #str2oid[nam] = oid
            pass
        else:
            str2oid[nam] = oid

    new_contents = format_as_map(oid2str, str2oid)
    file = open('src/lib/asn1/oid_maps.cpp', 'w')
    file.write(new_contents)
    file.close()

    return 0

if __name__ == '__main__':
    sys.exit(main())
