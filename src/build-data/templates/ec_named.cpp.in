/*
* ECC Group Info
* This file was automatically generated by {{ script }} on {{ date }}
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#include <botan/ec_group.h>

namespace Botan {

// clang-format off

//static
std::shared_ptr<EC_Group_Data> EC_Group::EC_group_info(const OID& oid) {
{%- for curve in curves %}
   // {{ curve["Name"] }}
   if({% for oid in curve["OIDExpr"] %}oid == {{ oid }}{% if not loop.last %} || {% endif %}{% endfor %}) {
      return load_EC_group_info(
         "0x{{ "%X" % curve["P"] }}",
         "0x{{ "%X" % curve["A"] }}",
         "0x{{ "%X" % curve["B"] }}",
         "0x{{ "%X" % curve["X"] }}",
         "0x{{ "%X" % curve["Y"] }}",
         "0x{{ "%X" % curve["N"] }}",
         {% if curve["OIDExpr"] | length == 1 %}oid{% else %}{{ curve["OIDExpr"][0] }}{% endif %});
   }
{% endfor %}
   return std::shared_ptr<EC_Group_Data>();
}

//static
OID EC_Group::EC_group_identity_from_order(const BigInt& order)
   {
   const uint32_t low_bits = static_cast<uint32_t>(order.word_at(0));
{% for curve in curves %}
   if(low_bits == 0x{{ "%08X" % curve["N32"]}} && order == BigInt("0x{{ "%X" % curve["N"] }}")) {
      return {{ curve["OIDExpr"][0] }};
   }
{% endfor %}
   return OID();
}

//static
const std::set<std::string>& EC_Group::known_named_groups() {
   static const std::set<std::string> named_groups = {
{{named_groups}}
   };

   return named_groups;
}

}  // namespace Botan

// clang-format on
